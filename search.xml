<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线段树Segment Tree]]></title>
    <url>%2FNing-Hui.github.io%2FSegment-Tree%2F</url>
    <content type="text"><![CDATA[迷茫 线段树学习问题导入给定一个长度为n的数组，有m次操作，每次操作可能如下： 1，修改 a[i] 的值 2，求连续一段区间的和 3， 求连续一段区间的最大值/最小值 4，给区间的每个数加上k 5，查询a[i] 的值。 如果对这个数据进行模拟操作，最差时间复杂度可能为O(mn) , 如果数据量非常大，处理起来非常容易超时。所以采用一种数据结构来优化。所以线段树就诞生了。 线段树线段树类似下图树状结构，用蒟蒻语说，就是“树状区间和”，即将一个二分过程表现出来。通过改变大区间的值，来实现短时区间计算。时间复杂度可以优化到O(logn) 线段树操作1.建树建树采用二分的方法 1234567891011121314void build(int l,int r,int node)&#123; if(l==r) &#123; scanf("%d",&amp;tree[node]); maxn[node] = tree[node]; return; &#125; int mid = (l+r)&gt;&gt;1; build(l,mid,node*2); build(mid+1,r,node*2+1); tree[node] = tree[node&lt;&lt;1] + tree[node&lt;&lt;1 | 1]; maxn[node] =max( maxn[node&lt;&lt;1] , maxn[node&lt;&lt;1|1] );&#125; 2.单点修改1234567891011121314151617181920//单点修改void change(int index,int key,int l,int r,int node)&#123; if(l==r) &#123; tree[node] = key; maxn[node] = key; return ; &#125; // push_down(node,mid-l+1,r-mid); 若既有点更新又有区间更新，需要这句话 int mid = (l+r)&gt;&gt;1; if(index&lt;=mid) change(index,key,l,mid,node&lt;&lt;1); else &#123; change(index,key,mid+1,r,node&lt;&lt;1|1); &#125; tree[node] = tree[node&lt;&lt;1] +tree[node&lt;&lt;1|1]; maxn[node] = max(maxn[node&lt;&lt;1] ,maxn[node&lt;&lt;1|1]);&#125; 3.区间和1234567891011121314151617181920//区间和int query_sum(int L,int R,int l,int r,int node)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; return tree[node]; &#125; int mid = (l+r)&gt;&gt;1; int sum = 0; if(L&lt;=mid) &#123; sum+=query_sum(L,R,l,mid,node*2); &#125; if(mid+1&lt;=R) &#123; sum+=query_sum(L,R,mid+1,r,node*2+1); &#125; return sum; &#125; 4.区间更新12345678910111213141516void change_range(int node,int l,int r,int L,int R,int key)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; lazy[node] +=1LL*key; tree[node]+=1LL*(r-l+1)*key; return ; &#125; //push_down(node,l,r); int mid = (l+r)&gt;&gt;1; if(l&lt;=mid) change_range(node&lt;&lt;1,l,mid,L,R,key); if(mid&lt;r) change_range(node&lt;&lt;1|1,mid+1,r,L,R,key); tree[node] = tree[node&lt;&lt;1] +tree[node&lt;&lt;1|1];&#125; 未完待续。。。。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则——常用匹配公式]]></title>
    <url>%2FNing-Hui.github.io%2Fre-expression%2F</url>
    <content type="text"><![CDATA[正则！正则！正则！正则！正则！正则！正则！正则！ 正则——常用匹配公式转载 一、数字校验123456789101112131415161718192021222324252627282930313233343536371 数字：^[0-9]*$2 n位的数字：^\d&#123;n&#125;$3 至少n位的数字：^\d&#123;n,&#125;$4 m-n位的数字：^\d&#123;m,n&#125;$5 零和非零开头的数字：^(0|[1-9][0-9]*)$6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7 带1-2位小数的正数或负数：^(-)?\d+(.\d&#123;1,2&#125;)?$8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*![或 ^([1-9][0-9]\*)&#123;1,3&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E(%5B1-9%5D%5B0-9%5D\*)%7B1%2C3%7D) 或 ^+?[1-9][0-9]*$12 非零的负整数：^-[1-9][]0-9&quot;*![或 ^-[1-9]\d*](https://math.jianshu.com/math?formula=%E6%88%96%20%5E-%5B1-9%5D%5Cd*)13 非负整数：^\d+![或 ^[1-9]\d*|0](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5B1-9%5D%5Cd*%7C0)14 非正整数：^-[1-9]\d*|0![或 ^((-\d+)|(0+))](https://math.jianshu.com/math?formula=%E6%88%96%20%5E((-%5Cd%2B)%7C(0%2B)))15 非负浮点数：^\d+(.\d+)?![或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5B1-9%5D%5Cd*%5C.%5Cd*%7C0%5C.%5Cd*%5B1-9%5D%5Cd*%7C0%3F%5C.0%2B%7C0)16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))![或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0](https://math.jianshu.com/math?formula=%E6%88%96%20%5E(-(%5B1-9%5D%5Cd*%5C.%5Cd*%7C0%5C.%5Cd*%5B1-9%5D%5Cd*))%7C0%3F%5C.0%2B%7C0)17 正浮点数：^[1-9]\d*.\d*|0.\d*[1-9]\d*![或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))](https://math.jianshu.com/math?formula=%E6%88%96%20%5E((%5B0-9%5D%2B%5C.%5B0-9%5D*%5B1-9%5D%5B0-9%5D*)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*%5C.%5B0-9%5D%2B)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*)))18 负浮点数：^-([1-9]\d*.\d*|0.\d*[1-9]\d*)![或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))](https://math.jianshu.com/math?formula=%E6%88%96%20%5E(-((%5B0-9%5D%2B%5C.%5B0-9%5D*%5B1-9%5D%5B0-9%5D*)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*%5C.%5B0-9%5D%2B)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*))))19 浮点数：^(-?\d+)(.\d+)?![或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)](https://math.jianshu.com/math?formula=%E6%88%96%20%5E-%3F(%5B1-9%5D%5Cd*%5C.%5Cd*%7C0%5C.%5Cd*%5B1-9%5D%5Cd*%7C0%3F%5C.0%2B%7C0)) 二、校验字符的表达式12345678910111213141516171819202122231 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2 英文和数字：^[A-Za-z0-9]+![或 ^[A-Za-z0-9]&#123;4,40&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5BA-Za-z0-9%5D%7B4%2C40%7D)3 长度为3-20的所有字符：^.&#123;3,20&#125;$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\w+![或 ^\w&#123;3,20&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5Cw%7B3%2C20%7D)9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+![或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5B%5Cu4E00-%5Cu9FA5A-Za-z0-9%5D%7B2%2C20%7D)11 可以输入含有^%&amp;&apos;,;=?![\&quot;等字符：[^%&amp;&apos;,;=?](https://math.jianshu.com/math?formula=%5C%22%E7%AD%89%E5%AD%97%E7%AC%A6%EF%BC%9A%5B%5E%25%26&apos;%2C%3B%3D%3F)\x22]+12 禁止输入含有的字符：[^\x22]+ 三、特殊需求表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;7 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?![或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5Cd%7B8%2C18%7D%7C%5B0-9x%5D%7B8%2C18%7D%7C%5B0-9X%5D%7B8%2C18%7D%3F)9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$12 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s*|\s*![或(^\s*)|(\s*](https://math.jianshu.com/math?formula=%E6%88%96(%5E%5Cs*)%7C(%5Cs*)) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字) 33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尺取法]]></title>
    <url>%2FNing-Hui.github.io%2Fruler-method%2F</url>
    <content type="text"><![CDATA[换换思路。休息一下。 尺取法尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。 Nowcode第一次写尺取法的代码，也是第一次接触。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3fll n,k; int main()&#123; cin&gt;&gt;n&gt;&gt;k; string s; cin&gt;&gt;s; int l,r,ans; ans = INF; int a[100]=&#123;0&#125;; l = r = 0; while(r&lt;s.size()) &#123; a[s[r]-'a']++; while(a[s[r]-'a']&gt;=k) &#123; ans = min(ans,r-l+1); a[s[l]-'a']-=1; l++; &#125; r++; &#125; if(ans==INF) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0; &#125; Poj3061题意：给定一个序列，使得其和大于或等于S，求最短的子序列长度。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;ll n,m;ll a[100010];int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; memset(a,0,sizeof(a)); for(int i =1;i&lt;=n;++i) cin&gt;&gt;a[i]; ll l,r; l = 1; r = 0; ll sum = 0; ll ans = INF; while(1) &#123; while(r&lt;=n&amp;&amp;sum&lt;m) sum+=a[++r]; if(sum&lt;m) break; ans = min(ans,r-l+1); sum-=a[l++]; &#125; if(ans==INF) ans = 0; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125; Poj3320题意：一本书有p页，每一页有一个知识点，知识点可能会重复，求最少连续页数覆盖所有知识点。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int N = 1000005;int a[N];map&lt;int,int&gt; mp;int main()&#123; int n; while(scanf("%d",&amp;n)!=EOF)&#123; mp.clear(); int m=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); if(mp[a[i]]==0) m++; mp[a[i]]=1; &#125; mp.clear(); int l=1,r=1,cnt=0,ans=n+1; while(l&lt;=n)&#123; while(r&lt;=n&amp;&amp;cnt&lt;m)&#123; if(mp[a[r]]==0) cnt++; mp[a[r]]++; r++; &#125; if(cnt&lt;m) break; if(cnt==m) ans = min(ans,r-l); mp[a[l]]--; if(mp[a[l]]==0) cnt--; l++; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ruler_method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Section DP]]></title>
    <url>%2FNing-Hui.github.io%2FSectionDP%2F</url>
    <content type="text"><![CDATA[世界上的人都变成废柴，这个世界就没有废柴了 区间DP区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。 既然求解在一个区间上的最优解，那么把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可。所以在代码实现上，我可以枚举区间长度len为每次分割成的小区间长度（由短到长不断合并），内层枚举该长度下可以的起点，自然终点也就明了了。然后在这个起点终点之间枚举分割点，求解这段小区间在某个分割点下的最优解。 123456789memset(dp,0,sizeof(dp))//初始dp数组for(int len=2;len&lt;=n;len++)&#123;//枚举区间长度 for(int i=1;i&lt;n;++i)&#123;//枚举区间的起点 int j=i+len-1;//根据起点和长度得出终点 if(j&gt;n) break;//符合条件的终点 for(int k=i;k&lt;=j;++k)//枚举最优分割点 dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);//状态转移方程 &#125;&#125; 优化 12345678910111213141516for(int len=2;len&lt;=n;len++)&#123; for(int i = 1;i&lt;=n;i++) &#123; int j = i+len-1; if(j&gt;n) break; for(int k = s[i][j-1];k&lt;=s[i+1][j];k++) &#123; if(dp[i][j]&gt;dp[i][k]+dp[k+1][j]+w[i][j]) &#123; dp[i][j]=dp[i][k]+dp[k+1][j]+w[i][j]; s[i][j]=k; &#125; &#125; &#125;&#125; Practice石子合并1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include &lt;numeric&gt;using namespace std;#define INF 0x3f3f3f3fint a[400],b[400];int dp[400][400];int main()&#123; int n ; cin&gt;&gt;n; memset(b,0,sizeof(b)); for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; //前缀和 //b[i] = b[i-1] +a[i]; &#125; //前缀和 partial_sum(a+1,a+1+n,b+1); for(int len = 2 ;len&lt;=n;++len)//枚举长度 &#123; for(int i=1;i+len-1&lt;=n;++i)//枚举起点 &#123; int l = i,r = len+i-1; dp[l][r] = INF; for(int k = l;k&lt;r;++k) &#123; dp[l][r] = min(dp[l][r],dp[l][k]+dp[k+1][r]+b[r]-b[l-1]); //区间[l,r]的代价 = min(当前状态,区间[l,k]的代价 + 区间[k+1,r]的代价 + [l,r]的代价和) &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; system("pause"); return 0;&#125; HDU42831234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[110],b[110];int dp[110][110];int main()&#123; int t; cin&gt;&gt;t; for(int num=1;num&lt;=t;++num ) &#123; int n; cin&gt;&gt;n; b[0] = 0; memset(dp,0,sizeof(dp)); for(int i= 1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; b[i] = a[i]+b[i-1]; &#125; for(int len=2;len&lt;=n;++len) &#123; for(int i =1;i+len-1&lt;=n;++i) &#123; int l = i, r = len+i-1; dp[l][r] = 1e9; for(int k=l;k&lt;=r;++k) dp[l][r] = min(dp[l][r],dp[l+1][k]+dp[k+1][r]+(k-l+1)*(b[r]-b[k])+a[i]*(k-i)); &#125; &#125; //cout&lt;&lt;dp[1][n]&lt;&lt;endl; printf("Case #%d: %d\n",num,dp[1][n]); &#125; return 0;&#125; POJ2955括号最长匹配长度。 1234567891011121314151617181920212223242526272829303132333435363738394041/*用dp[l][r]表示区间[l,r]里最大完全匹配数。只要得到了dp[l][r]，那么就可以得到dp[i-1][j+1] dp[i-1][j+1]=dp[i][j]+(s[i-1]==s[j+1]？2:0).*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;ll dp[110][110];char s[110];int main()&#123; while(cin&gt;&gt;s+1) &#123; if(s[1] == 'e') break; memset(dp,0,sizeof(dp)); ll len = strlen(s+1); for(int lenn = 1;lenn&lt;=len;++lenn)//枚举长度 &#123; for(int i =1;i+lenn-1&lt;=len;++i)//枚举端点 &#123; int l = i,r = i+lenn-1; //如果知道了区间[l,r]的个数，那么很容易求出dp[l+1][r-1]的个数 if((s[l]=='('&amp;&amp;s[r]==')') || (s[l]=='['&amp;&amp;s[r]==']')) dp[l][r] = dp[l+1][r-1] + 2; //枚举分界点 for(int k = l;k&lt;r;++k) dp[l][r] = max(dp[l][r],dp[l][k]+dp[k+1][r]); &#125; &#125; cout&lt;&lt;dp[1][len]&lt;&lt;endl; &#125; return 0;&#125; 整数划分1234567题意：给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积思路：这里给的乘号是有限个，所以状态方程里必须包含使用乘号的个数，此外还要包含区间长度。所以怎么用二维dp实现包含m和n，我们可以用dp[i][j]表示在第1~i个字符里插入j个乘号的最大值。状态转移方程 dp[i][j]表示在第1~i个字符里插入j个乘号的最大值；用num[i][j]表示第i~j个字符表示的数字；dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*题意：给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积思路：这里给的乘号是有限个，所以状态方程里必须包含使用乘号的个数，此外还要包含区间长度。所以怎么用二维dp实现包含m和n，我们可以用dp[i][j]表示在第1~i个字符里插入j个乘号的最大值。状态转移方程 dp[i][j]表示在第1~i个字符里插入j个乘号的最大值；用num[i][j]表示第i~j个字符表示的数字；dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i])*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll m;char s[110];ll dp[110][110];ll num[110][110];int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0,sizeof(dp)); memset(num,0,sizeof(num)); cin&gt;&gt;s+1; cin&gt;&gt;m; int len = strlen(s+1); for(int i =1;i&lt;=len;++i) &#123; for(int j =i;j&lt;=len;++j) &#123; num[i][j] = num[i][j-1]*10+(s[j]-'0'); &#125; &#125; for(int i=1;i&lt;=len;++i) dp[i][0] = num[1][i]; for(int j =1;j&lt;m;++j)//插入第j个* &#123; for(int i = 1;i&lt;=len;++i) &#123; for(int k =1;k&lt;i;++k) &#123; dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i]); &#125; &#125; &#125; cout&lt;&lt;dp[len][m-1]&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Section DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冬日]]></title>
    <url>%2FNing-Hui.github.io%2Fwinter-scenery%2F</url>
    <content type="text"><![CDATA[冬日。感谢美丽的摄影师（ORZ）]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Scenery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陌上花开]]></title>
    <url>%2FNing-Hui.github.io%2Frecord%2F</url>
    <content type="text"><![CDATA[12月的第一天，也是一年中的最后一个月，不知不觉你又长大一岁。 纤尘陌陌终有花开时,花开一季芬芳至永远。陌上那千年的等候,终究等来了花开一世的最终绚烂。陌上花开已迟暮,但终究在千年的等候里绽放出了美丽。这份美丽,或许于陌上而言,真的是经久的等待。或许,陌上早已有了等不来陌上花开的平和,如若陌上花开,阡陌或许觉得已经是生命的奇迹了。 纤尘陌陌里,风舞尽沙,在千年的翘首里,阡陌已经忘了什么是风和沙的 缠绵。在终年的清寂里,阡陌或许看透尘世,舞尽人生,不再对花开有所期待。对于突然在陌上开出的那朵尘世青莲,或许是经久等待之外的惊喜。 秋风习习里,绝尘于陌上那孤寂的青莲,在不知不觉中已露尖尖角,那花 蕾在晨露里绽吐芬芳。它已经错过了花开的最好季节,在秋已至的时候,抹开了沉睡已久的眼,终于明白自己为什么沉睡这么久,只因一直在寻找属于自己生命的阡陌。 或许,属于它生命的阡陌一直在尘世的浮华里,未曾停留。所以千百年来的找寻,终究一次次的和属于它生命的阡陌错过。青莲想它这一生,或许已经找不到属于它生命的那方净土了。于是,沉睡再沉睡,在所有的睡意朦胧里,诠释着自己的前世今生。 不过,青莲是倔强的,惟有找到它想要的阡陌,才愿意在这世绽放属于它自己的美丽。如若,遇不到给它灵魂洗涤的净土,它将永远的沉睡下去,不再醒来。或许,这份倔强终究有一天会感动苍天,让它在醒来的时候遇到了能让它娇艳开放的那方阡陌。 几经轮回,沉睡之中醒来再沉睡,反复了千年,不怕一直在纤尘里流离,只因找不到让它尘埃落定的芬芳。经久的沉睡,但是记忆的芬芳一直是浓郁的,它明白自己为何一直在沉睡,因为在等待着属于它芬芳的阡陌风尘仆仆而来。 所有的轮回里,遇到错过,错过再遇,一场场的浩劫最青莲它把自己禁锢 在了沉睡里。青莲明白自己只是倔强又绝然的,在等着属于它的那一方陌,那一池水。如若能拥有自己想要的阡陌,最后自己的生命会归于一切的平静之中。 青莲或许已经闻到了那方属于它的阡陌的味道,只是那方阡陌还在遥远的地方苍凉的遥望。青莲明白,总有一天自己等待着的那方陌,那池水,会从滚滚的红尘里最后卸下所有的喧嚣,还一切一片清寂。卸下所有的繁华,卸下所有的琐碎,呈有素颜的那天。 青莲明白自己这样倔强的沉睡,为的就是找寻属于自己生命的那方阡陌。它最终需要的是不醉红尘只醉君的那份酣畅淋漓,或许此生也找不到这样的酣畅淋漓。但她自己知道,如若君不来,它就迟迟不开,不管是千年还是万年,永远的沉睡下去。如若君,一世的颠沛流离,那么它就一世的孤芳沉睡。 ——《陌上花开》]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RKGE_论文阅读笔记]]></title>
    <url>%2FNing-Hui.github.io%2FRKGE%2F</url>
    <content type="text"><![CDATA[while(1) { cout&lt;&lt;”Never Give Up”&lt;&lt;endl; } RKGEAbstract首先，知识图谱已经被证明，可以有效的提高推荐系统的推荐能力。但是也有不足，主要是知识图谱的手动设计的特征（Existing methods mainly rely on hand-engineered features from KGs (e.g., meta paths),）。据此，提出了本篇文章的知识图谱嵌入方法，来自动的学习实体路径的语义表示和实体之间的路径，以描述用户对项目的偏好，解决上述问题。 Introduction首先介绍了目前最先进的方法是基于元路径的方法，但是，摘要中提到的，基于元路径的方法严重依赖于手工构造特征来表示路径语义，而路径语义有进一步依赖于领域知识，并且手工设计的特征可能不是很充分，无法覆盖所有可能的实体关系，这也是主要缺点。 下文又介绍了知识图谱嵌入的方法来推荐，尽管相比于元路径提高了性能，但局限性是忽略了实体之间的语义关系。为此，解决上述方法提出了，RKGE 就拿上图举例子，我们可以找到这样的路径 P(people)——&gt; M（moive）——&gt; C（categories）——&gt;M（Moive） P——&gt;M——&gt;D(director)——&gt;M P——&gt;M——&gt;A(actor)——&gt;M ……….. 等等这些不同长度，不同语义路径关系，可以有很多条，可以有效的找出用户的喜好品味，同时，可以作出不同的电影推荐。这里就有一个问题，这个人会喜欢这些推荐的所有电影吗？答案当然是不是，每个人都有一个偏好。 为此，用递归神经网络来学习实体语义关系，通过循环网路找出不同的语义路径。建立路径模型。提出递归知识图谱嵌入的框架RKGE，捕获路径。为区别不同路径的权重，采用池化操作来区分 Related work基于图的方法主要通过随机游走模型，但容易被流行的实体和中间的实体所偏离。 他们只考虑了KG的拓扑结构，而没有考虑对知识图谱中实体的语义和实体关系进行建模，从而没有充分利用知识图谱进行推荐 基于元路径的方法元路径限制于手工设计特征，限制了推荐系统推荐能力的提高。 基于知识图谱嵌入的方法不能完全捕获实体之间的关系，忽略了实体对之间的关系。 最后总结，RKGE可以解决目前state-of-the-art推荐方法的一些缺点。 RKGE通过给定的数据，利用知识图谱编码的异构信息信息来帮助学习用户和项目之间的更贴切关系，然后用它们来进行更好的推荐。所提取的特征可以完全捕获知识图谱中所编码的实体和实体关系的语义。 操作过程 具体来说，RKGE采用了一种新的递归网络架构，该架构包含一批递归网络，用于对链接相同实体对的路径的语义建模，这些路径无缝地融合到推荐中。它还使用了一个池操作符来区分不同路径在描述用户对项目的偏好时的重要性。 为了更好的挖掘数据中用户与项目之间的关系，提出了两种语义路径挖掘的方法： 只考虑用户到项目之间的路径和这个用户评过分的项目。同时，还会得到用户-用户，项目-项目，这些用户到项目的子序列。 设定阈值。避免引入大量的噪声，失去语义意义。 2.递归网络 主要优点：它们对不同长度的序列进行建模的，以及捕获实体和实体对之间的整个路径的语义的能力 设计了一个网络体系结构来搜索所有可能的关系，它包含了一批递归网络，每个递归网络学习单个路径的语义表示。 递归网络通过学习每个实体的语义表示和整个路径的单一表示对路径进行编码。在RKGE中，这些目标是通过两个网络层来实现的，即嵌入层和注意门控隐藏层。 嵌入层对于p中的每个实体e，嵌入层学习一个分布式表示p，将e映射为一个低维向量，该向量的每个元素表示该实体与潜在语义的密切关系，从而捕获实体的语义意义。 注意门控隐藏层为了学习路径表示，隐含层考虑了路径中实体的嵌入和这些实体的顺序。采用基于流的方法，从路径开始到结束的序列编码。采用注意门机制来控制信息流 3.决策方案研究表明较短的路径可能比较长的路径具有更大的影响，因为较短的路径通常表示具有更强的连接性和更清晰的语义。 注意力机制也能解决这个问题。但是，它的目标通常是识别单个序列中每个元素的重要性，与目标相背。 所以通过池化操作来实现这个操作。 池化有两个操作，实验证明，最大池化相比于平均池化有更好的效果。 Algorithm核心算法]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RKGE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现贪吃蛇小游戏]]></title>
    <url>%2FNing-Hui.github.io%2Fsnake-game%2F</url>
    <content type="text"><![CDATA[一起来玩游戏？ python实现贪吃蛇小游戏先来看看这个小游戏 没错这就是强大的python，实现所有不可能。 先前，有了解到用人工智能训练贪吃蛇，没错就是snake，可以达到很高的分数，并且损失函数随训练次数的增加，逐渐降低，贪吃蛇能够更准确的吃到食物，简直太神奇了。 最近学习了DFS，BFS，这两个搜索图的算法，完全可以用这两个基础算法来实现人工智能的贪吃蛇，A*也可以。算法的主要思路就是通过获取蛇的头部和食物的位置，在避免碰到自己和边缘的前提下进行路径规划。好了就说到这。 下面给出这个贪吃蛇的代码，不是AI-snake哦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328import sysimport osimport pygameimport randomimport mathpygame.init()pygame.display.set_caption("$nAke bRo color fUll--FASAL ")pygame.font.init()random.seed()#globalSPEED = 0.36SNAKE_SIZE = 9APPLE_SIZE = SNAKE_SIZESEPARATION = 10SCREEN_HEIGHT = 600SCREEN_WIDTH = 800FPS = 25KEY = &#123;"UP":1,"DOWN":2,"LEFT":3,"RIGHT":4&#125;#Screen initializationscreen = pygame.display.set_mode((SCREEN_WIDTH,SCREEN_HEIGHT),pygame.HWSURFACE)#Resourcesscore_font = pygame.font.Font(None,38)score_numb_font = pygame.font.Font(None,28)game_over_font = pygame.font.Font(None,46)play_again_font = score_numb_fontscore_msg = score_font.render("Score:",1,pygame.Color("red"))score_msg_size = score_font.size("Score")#pygame coloration for aquabackground_color = pygame.Color(0,255,255)black = pygame.Color(0,255,255)#ClockgameClock = pygame.time.Clock()def checkCollision(posA,As,posB,Bs): #As size of a | Bs size of B if(posA.x &lt; posB.x+Bs and posA.x+As &gt; posB.x and posA.y &lt; posB.y + Bs and posA.y+As &gt; posB.y): return True return Falsedef checkLimits(entity): if(entity.x &gt; SCREEN_WIDTH): entity.x = SNAKE_SIZE if(entity.x &lt; 0): entity.x = SCREEN_WIDTH - SNAKE_SIZE if(entity.y &gt; SCREEN_HEIGHT): entity.y = SNAKE_SIZE if(entity.y &lt; 0): entity.y = SCREEN_HEIGHT - SNAKE_SIZEclass Apple: def __init__(self,x,y,state): self.x = x self.y = y self.state = state self.color = pygame.color.Color("red") def draw(self,screen): pygame.draw.rect(screen,self.color,(self.x,self.y,APPLE_SIZE,APPLE_SIZE),0)class Segment: def __init__(self,x,y): self.x = x self.y = y self.direction = KEY["UP"] self.color = "red"class Snake: def __init__(self,x,y): self.x = x self.y = y self.direction = KEY["UP"] self.stack = [] self.stack.append(self) blackBox = Segment(self.x,self.y + SEPARATION) blackBox.direction = KEY["UP"] blackBox.color = "NULL" self.stack.append(blackBox) def move(self): last_element = len(self.stack)-1 while(last_element != 0): self.stack[last_element].direction = self.stack[last_element-1].direction self.stack[last_element].x = self.stack[last_element-1].x self.stack[last_element].y = self.stack[last_element-1].y last_element-=1 if(len(self.stack)&lt;2): last_segment = self else: last_segment = self.stack.pop(last_element) last_segment.direction = self.stack[0].direction if(self.stack[0].direction ==KEY["UP"]): last_segment.y = self.stack[0].y - (SPEED * FPS) elif(self.stack[0].direction == KEY["DOWN"]): last_segment.y = self.stack[0].y + (SPEED * FPS) elif(self.stack[0].direction ==KEY["LEFT"]): last_segment.x = self.stack[0].x - (SPEED * FPS) elif(self.stack[0].direction == KEY["RIGHT"]): last_segment.x = self.stack[0].x + (SPEED * FPS) self.stack.insert(0,last_segment) def getHead(self): return(self.stack[0]) def grow(self): last_element = len(self.stack)-1 self.stack[last_element].direction = self.stack[last_element].direction if(self.stack[last_element].direction == KEY["UP"]): newSegment = Segment(self.stack[last_element].x,self.stack[last_element].y-SNAKE_SIZE) blackBox = Segment(newSegment.x,newSegment.y-SEPARATION) elif(self.stack[last_element].direction == KEY["DOWN"]): newSegment = Segment(self.stack[last_element].x,self.stack[last_element].y+SNAKE_SIZE) blackBox = Segment(newSegment.x,newSegment.y+SEPARATION) elif(self.stack[last_element].direction == KEY["LEFT"]): newSegment = Segment(self.stack[last_element].x-SNAKE_SIZE,self.stack[last_element].y) blackBox = Segment(newSegment.x-SEPARATION,newSegment.y) elif(self.stack[last_element].direction == KEY["RIGHT"]): newSegment = Segment(self.stack[last_element].x+SNAKE_SIZE,self.stack[last_element].y) blackBox = Segment(newSegment.x+SEPARATION,newSegment.y) blackBox.color = "NULL" self.stack.append(newSegment) self.stack.append(blackBox) def iterateSegments(self,delta): pass def setDirection(self,direction): if(self.direction == KEY["RIGHT"] and direction == KEY["LEFT"] or self.direction == KEY["LEFT"] and direction == KEY["RIGHT"]): pass elif(self.direction == KEY["UP"] and direction == KEY["DOWN"] or self.direction == KEY["DOWN"] and direction == KEY["UP"]): pass else: self.direction = direction def get_rect(self): rect = (self.x,self.y) return rect def getX(self): return self.x def getY(self): return self.y def setX(self,x): self.x = x def setY(self,y): self.y = y def checkCrash(self): counter = 1 while(counter &lt; len(self.stack)-1): if(checkCollision(self.stack[0],SNAKE_SIZE,self.stack[counter],SNAKE_SIZE)and self.stack[counter].color != "NULL"): return True counter+=1 return False def draw(self,screen): pygame.draw.rect(screen,pygame.color.Color("yellow"),(self.stack[0].x,self.stack[0].y,SNAKE_SIZE,SNAKE_SIZE),0) counter = 1 while(counter &lt; len(self.stack)): if(self.stack[counter].color == "NULL"): counter+=1 continue pygame.draw.rect(screen,pygame.color.Color("white"),(self.stack[counter].x,self.stack[counter].y,SNAKE_SIZE,SNAKE_SIZE),0) counter+=1def getKey(): for event in pygame.event.get(): if event.type == pygame.KEYDOWN: if event.key == pygame.K_UP: return KEY["UP"] elif event.key == pygame.K_DOWN: return KEY["DOWN"] elif event.key == pygame.K_LEFT: return KEY["LEFT"] elif event.key == pygame.K_RIGHT: return KEY["RIGHT"] elif event.key == pygame.K_ESCAPE: return "exit" elif event.key == pygame.K_y: return "yes" elif event.key == pygame.K_n: return "no" if event.type == pygame.QUIT: sys.exit()def respawnApple(apples,index,sx,sy): radius = math.sqrt((SCREEN_WIDTH/2*SCREEN_WIDTH/2 + SCREEN_HEIGHT/2*SCREEN_HEIGHT/2))/2 angle = 999 while(angle &gt; radius): angle = random.uniform(0,800)*math.pi*2 x = SCREEN_WIDTH/2 + radius * math.cos(angle) y = SCREEN_HEIGHT/2 + radius * math.sin(angle) if(x == sx and y == sy): continue newApple = Apple(x,y,1) apples[index] = newAppledef respawnApples(apples,quantity,sx,sy): counter = 0 del apples[:] radius = math.sqrt((SCREEN_WIDTH/2*SCREEN_WIDTH/2 + SCREEN_HEIGHT/2*SCREEN_HEIGHT/2))/2 angle = 999 while(counter &lt; quantity): while(angle &gt; radius): angle = random.uniform(0,800)*math.pi*2 x = SCREEN_WIDTH/2 + radius * math.cos(angle) y = SCREEN_HEIGHT/2 + radius * math.sin(angle) if( (x-APPLE_SIZE == sx or x+APPLE_SIZE == sx) and (y-APPLE_SIZE == sy or y+APPLE_SIZE == sy) or radius - angle &lt;= 10): continue apples.append(Apple(x,y,1)) angle = 999 counter+=1def endGame(): message = game_over_font.render("Game Over",1,pygame.Color("white")) message_play_again = play_again_font.render("Play Again? Y/N",1,pygame.Color("green")) screen.blit(message,(320,240)) screen.blit(message_play_again,(320+12,240+40)) pygame.display.flip() pygame.display.update() myKey = getKey() while(myKey != "exit"): if(myKey == "yes"): main() elif(myKey == "no"): break myKey = getKey() gameClock.tick(FPS) sys.exit()def drawScore(score): score_numb = score_numb_font.render(str(score),1,pygame.Color("red")) screen.blit(score_msg, (SCREEN_WIDTH-score_msg_size[0]-60,10) ) screen.blit(score_numb,(SCREEN_WIDTH - 45,14))def drawGameTime(gameTime): game_time = score_font.render("Time:",1,pygame.Color("red")) game_time_numb = score_numb_font.render(str(gameTime/1000),1,pygame.Color("red")) screen.blit(game_time,(30,10)) screen.blit(game_time_numb,(105,14))def exitScreen(): passdef main(): score = 0 #Snake initialization mySnake = Snake(SCREEN_WIDTH/2,SCREEN_HEIGHT/2) mySnake.setDirection(KEY["UP"]) mySnake.move() start_segments=3 while(start_segments&gt;0): mySnake.grow() mySnake.move() start_segments-=1 #Apples max_apples = 1 eaten_apple = False apples = [Apple(random.randint(60,SCREEN_WIDTH),random.randint(60,SCREEN_HEIGHT),1)] respawnApples(apples,max_apples,mySnake.x,mySnake.y) startTime = pygame.time.get_ticks() endgame = 0 while(endgame!=1): gameClock.tick(FPS) #Input keyPress = getKey() if keyPress == "exit": endgame = 1 #Collision check checkLimits(mySnake) if(mySnake.checkCrash()== True): endGame() for myApple in apples: if(myApple.state == 1): if(checkCollision(mySnake.getHead(),SNAKE_SIZE,myApple,APPLE_SIZE)==True): mySnake.grow() myApple.state = 0 score+=5 eaten_apple=True #Position Update if(keyPress): mySnake.setDirection(keyPress) mySnake.move() #Respawning apples if(eaten_apple == True): eaten_apple = False respawnApple(apples,0,mySnake.getHead().x,mySnake.getHead().y) #Drawing screen.fill(background_color) for myApple in apples: if(myApple.state == 1): myApple.draw(screen) mySnake.draw(screen) drawScore(score) gameTime = pygame.time.get_ticks() - startTime drawGameTime(gameTime) pygame.display.flip() pygame.display.update()main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>snake_game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort() function]]></title>
    <url>%2FNing-Hui.github.io%2Fsort_function%2F</url>
    <content type="text"><![CDATA[C++中的sort（）函数我在之前的博客中提到，解决排序问题的一个好用的函数就是C++的sort（）函数啦。sort（）函数是C++内置的函数，只需要加入头文件，掌握正确的使用方法，你就可以在排序中驰骋疆场了（自吹自擂）。好啦，下面就请主角登场吧 sort()1.介绍c++语言中 STL 库中的sort函数可以用来对数组进行排序。对于c++语言来说由于其自带的sort()函数更容易被编译器编译，其排序速度比基于快速排序的qsort要快上不少，且用法简单。(百度知道) 2.准备sort（）函数的使用需要添加头文件 123#include&lt;algorithm&gt;或者万能头文件#include&lt;bits/stdc++.h&gt; 3.使用方法sort（star,end,cmp）* sort函数有三个参数： 1.第一个是要排序的数组的起始地址 2.第二个是结束地址（最后一位的地址的下一地址） 3.第三个参数是排序的方法。sort函数默认是按从小到大排序。可以修改cmp实现从大到小排序 123sort（begin，end，less&lt;data-type&gt;)——升序sort（begin，end，greater&lt;data-type&gt;)——降序 以上是比较简单常用的对数组的排序方法，sort（）类函数中还有其他的排序功能。 4.sort()类函数 函数名 功能描述 sort 对给定区间所有元素进行排序 stable_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素部分排序 partial_sort_copy 对给定区间复制并排序 nth_element 找出给定区间的某个位置对应的元素 is_sorted 判断一个区间是否已经排好序 partition 使得符合某个条件的元素放在前面 stable_partition 相对稳定的使得符合某个条件的元素放在前面 5.sort（）函数练习1.有序序列合并链接： https://ac.nowcoder.com/acm/contest/827/J 来源：牛客网 题目描述 输入两个升序排列的序列，将两个序列合并为一个有序序列并输出。 输入描述: 1234567输入包含三行，第一行包含两个正整数n, m（1 ≤ n,m ≤ 100），用空格分隔。n表示第二行第一个升序序列中数字的个数，m表示第三行第二个升序序列中数字的个数。第二行包含n个整数（范围1~5000），用空格分隔。第三行包含m个整数（范围1~5000），用空格分隔。 输出描述: 输出为一行，输出长度为n+m的升序序列，即长度为n的升序序列和长度为m的升序序列中的元素重新进行升序序列排列合并。 示例1 输入5 61 3 7 9 222 8 10 17 33 44输出1 2 3 7 8 9 10 17 22 33 44 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,m,t;int a[100],b[100],c[200];int main()&#123; cin&gt;&gt;n&gt;&gt;m; t=n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; c[i]=a[i]; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;b[i]; c[t++]=b[i]; &#125; sort(c,c+m+n); for(int i=0;i&lt;m+n;i++) &#123; cout&lt;&lt;c[i]; putchar(' '); &#125; return 0; &#125; 2.最高最低分差链接： https://ac.nowcoder.com/acm/contest/827/E 来源：牛客网 题目描述 输入n个成绩，换行输出n个成绩中最高分数和最低分数的差。 输入描述: 123两行，第一行为n，表示n个成绩，不会大于10000。第二行为n个成绩（整数表示，范围0~100），以空格隔开。 输出描述: 1一行，输出n个成绩中最高分数和最低分数的差。 示例1 输入 121098 100 99 97 95 99 98 97 96 100 输出 5 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[10000],sum=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); sum=a[n-1]-a[0]; printf("%d",sum); return 0; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
</search>
